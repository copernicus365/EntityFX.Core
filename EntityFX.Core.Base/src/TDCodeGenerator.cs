using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

using EntityFX.Core.Internal;

namespace EntityFX.Core
{
	public class TDCodeGenerator
	{
		/// <summary>
		/// (Housekeeping: rework this description...)
		/// A dictionary with keys matching the table names, 
		/// and values matching a string representing one or more interfaces to append to the generated
		/// TD (table definition) code. So an entity CLR object called 'Alert' might have a SQL Table 
		/// named Alerts. If the input dictionary has a key named 'Alerts', the value (likely a single
		/// interface value, like 'IBizId') will now be set as an inteface on AlertsTD: 
		/// <code>public class AlertsTD : IBizId, ITableDefinition</code>.
		/// </summary>
		public Dictionary<string, string> ExtraInterfacesPerTD { get; set; }

		public string CodeNamespace { get; set; }

		public string[] UsingDirectives { get; set; }

		public static string DefaultCodeNamespace { get; set; } = "EntityFX.TDs";

		static readonly string[] _necessaryUsings = { "System", "System.Collections.Generic", "System.Linq", "EntityFX.Core" };

		public string WrapTableDefinitionsCodeInOuterNamespaceAndUsings(
			IList<string> codes,
			StringBuilder sb = null)
		{
			if(sb == null)
				sb = new StringBuilder(codes.Sum(s => s.Length) + 1024);

			// --- write auto-gen header ---

			string autoGeneratedHdr = AutoGeneratedLine();

			sb
				.AppendLine(autoGeneratedHdr)
				.AppendLine();

			// --- write usings ---

			var usingDirectivesDict = GetUsingDirectives();

			foreach(string u in usingDirectivesDict.Keys)
				sb.AppendLine($"using {u};");

			// --- write namespace ---

			sb.Append(
@"

namespace ");

			string ns = CodeNamespace.NullIfEmptyTrimmed() ?? DefaultCodeNamespace.NullIfEmptyTrimmed();
			if(ns.IsNulle())
				throw new ArgumentNullException(nameof(CodeNamespace), $"Either {nameof(CodeNamespace)} or {nameof(DefaultCodeNamespace)} must be set");

			sb.Append(ns);

			sb.Append(@"
{
");

			// --- write code tds ---

			foreach(var code in codes)
				sb.AppendLine(code);

			// --- write end ---

			sb.Append(@"
}
");

			string result = sb.ToString();
			return result;
		}

		public string GetStronglyTypedTableDefinitionCode(ITableMetaInfo tmi)
		{
			string[] tblCols = tmi.TableColumnNames;
			string[] entCols = tmi.EntityPropertyNames;

			if(tmi.TableName.IsNulle() || tblCols.IsNulle() || tblCols.Length != entCols.Length)
				throw new ArgumentException();

			string finalInterfaceExtraVal = null;
			if(ExtraInterfacesPerTD.NotNulle()) {
				if(ExtraInterfacesPerTD.TryGetValueAny(out finalInterfaceExtraVal, tmi.TypeName, tmi.TypeNameFull, tmi.TableName))
					finalInterfaceExtraVal += ", ";
			}

			var sb = new StringBuilder();

			// --- Class Definition ---
			sb.AppendFormat(
@"
	#region {0}TD
	
	public class {0}TD : {1}ITableDefinition
	{{
", tmi.TypeName, finalInterfaceExtraVal); // using EntityName instead of TableName

			// --- Static Column Values ---
			sb.Append("		#region --- CONST PROPERTY NAMES ---\r\n\r\n");

			for(int i = 0; i < tblCols.Length; i++)
				sb.AppendFormat("		public const string _{0} = \"{1}\";\r\n", entCols[i], tblCols[i]);

			sb.Append("\r\n		#endregion\r\n\r\n");

			// --- Add _TableColumnNames ---
			string columnsJoined = entCols.JoinToString(", _");

			// --- Column Properties ---
			sb.Append("		#region --- Strongly Typed Instance Table Column Names ---\r\n\r\n");

			for(int i = 0; i < tblCols.Length; i++)
				sb.AppendFormat("		public string {0} => _{0};\r\n", entCols[i]);

			sb.Append("\r\n		#endregion\r\n\r\n");


			// =-=-= ITableDefinition Properties =-=-=

			sb.Append("		#region =-=-= STATIC FIELDS =-=-=\r\n\r\n")
				.AppendFormat("		public static readonly string[] _TableColumnNames = {{ _{0} }};\r\n", columnsJoined)
				.AppendLine()
				.AppendFormat("		public static readonly string[] _EntityPropertyNames = {{ \"{0}\" }};\r\n", entCols.JoinToString("\", \""))
				.AppendLine();

			string tableMetaInfoCode = tmi.GetTableMetaInfoCode();
			sb.AppendMany(
				"		public static TableMetaInfo _TableMeta = ",
				tableMetaInfoCode);

			sb.AppendLine()
				.AppendLine()
				.AppendLine($"		public string[] {nameof(tmi.TableColumnNames)} => _TableColumnNames;")
				.AppendLine($"		public string[] {nameof(tmi.EntityPropertyNames)} => _EntityPropertyNames;")
				.AppendLine("		public TableMetaInfo TableMeta { get => _TableMeta; set { _TableMeta = value; } }")
				.AppendLine();

			sb.Append("		#endregion\r\n\r\n")
				.Append(
@"	}

	#endregion");

			string result = sb.ToString();
			return result;
		}

		public string GetTableDefinitionsCodeForEntityTypes(
			ITableMetaInfoBuilder tmiBldr,
			IEnumerable<Type> types,
			TDCodeGenerator codeGenOps = null,
			bool withNamespace = true)
		{
			if(types == null) return null;

			Type[] arr = types.ToArray();

			var codes = new List<string>(arr.Length);

			for(int i = 0; i < arr.Length; i++) {
				Type t = arr[i];
				string code = tmiBldr.GetTableDefinitionCode(
					t,
					codeGenOps,
					withNamespace: false); // must NOT have ns!
				codes.Add(code);
			}

			if(!withNamespace)
				return codes.JoinToString("\r\n");

			return codeGenOps.WrapTableDefinitionsCodeInOuterNamespaceAndUsings(codes);
		}

		public static string GetTableMetaInfoCode(ITableMetaInfo tmi)
			=> GetTableMetaInfoCodeStatic(tmi);

		public static string GetTableMetaInfoCodeStatic(ITableMetaInfo tmi)
		{
			string result =
		$@"new {nameof(TableMetaInfo)}() {{
			{nameof(tmi.TableName)} = ""{tmi.TableName}"",
			{nameof(tmi.TableSchema)} = ""{tmi.TableSchema}"",
			{nameof(tmi.TableNameFull)} = ""{tmi.TableNameFull}"",
			{nameof(tmi.TypeName)} = ""{tmi.TypeName}"",
			{nameof(tmi.TypeNameFull)} = ""{tmi.TypeNameFull}"",
			{nameof(tmi.TableColumnNames)} = _TableColumnNames.ToArray(),
			{nameof(tmi.EntityPropertyNames)} = _EntityPropertyNames.ToArray()
		}};";

			return result;
		}

		public string GetTableDefinitionCode(
			ITableMetaInfo tinfo,
			bool withNamespace = true)
		{
			string code = GetStronglyTypedTableDefinitionCode(tinfo);

			if(withNamespace) {
				code = WrapTableDefinitionsCodeInOuterNamespaceAndUsings(new string[] { code });
			}
			return code;
		}

		public string GetTableDefinitionCode(
			ITableMetaInfoBuilder tmiBldr,
			Type type,
			bool withNamespace = true)
		{
			TableMetaInfo tinfo = tmiBldr.GetTableMetaInfo(type);

			string code = GetStronglyTypedTableDefinitionCode(tinfo);

			if(withNamespace)
				code = WrapTableDefinitionsCodeInOuterNamespaceAndUsings(new string[] { code });

			return code;
		}


		public static Dictionary<string, string> GetExtraTDInterfacesPerEntityInterace(
			params (Type entityInterface, Type tableDefInterfaceForEntityInterface)[] kvs)
		{
			var dict = new Dictionary<string, string>();

			foreach((Type entityInterface, Type tableDefInterfaceForEntityInterface) in kvs) {

				string tdTypeFullName = tableDefInterfaceForEntityInterface.Name;

				foreach(Type entityType in entityInterface
					.GetTypesImplementingThisInterface()
					.Where(t => !t.IsInterface)) {

					dict[entityType.FullName] = tdTypeFullName;
				}
			}

			return dict; // OLD: See #1 below
		}

		public string WriteNewTableDefinitionsCode(
			IList<string> tableDefinitionCodes,
			string pathTDsCSFile,
			string pathTDsOldCommentedOutCSFile = null,
			int maxLinesToSaveOldCommentedOutVersion = 10_000)
		{
			//WrapTableDefinitionsCodeInOuterNamespaceAndUsings(
			//DbContext dbContext = generatedTDCodesPerDbContext[i];
			//string tdDbContextCode = dbContext.GetTableDefinitionsCodeForAllDbSets(codeGenerator1);

			string val = WrapTableDefinitionsCodeInOuterNamespaceAndUsings(tableDefinitionCodes);

			string path = pathTDsCSFile.NullIfEmptyTrimmed();

			if(path.IsNulle() || !File.Exists(path))
				throw new FileNotFoundException(null, path);

			if(maxLinesToSaveOldCommentedOutVersion > 0) {

				var sb = new StringBuilder()
					.AppendLine(AutoGeneratedLine())
					.AppendLine();

				string[] currLines = File.ReadAllLines(path);

				for(int i = 0; i < currLines.Length && i < maxLinesToSaveOldCommentedOutVersion; i++) {
					string line = currLines[i];
					sb.Append("//");
					sb.AppendLine(line);
				}

				pathTDsOldCommentedOutCSFile = pathTDsOldCommentedOutCSFile.NullIfEmptyTrimmed(); //Path_TableDefinitionsOldCommentedOutCSFile
				if(pathTDsOldCommentedOutCSFile == null) {
					pathTDsOldCommentedOutCSFile = $"{Path.GetDirectoryName(path)}\\exclude\\{Path.GetFileNameWithoutExtension(path)}-old-{_toXmlTime(DateTime.UtcNow)}.cs"
						.Replace("\\\\", "\\");
				}

				string oldVal = sb.ToString();

				File.WriteAllText(pathTDsOldCommentedOutCSFile, oldVal);
			}

			File.WriteAllText(path, val);
			return val;
		}

		public Dictionary<string, bool> GetUsingDirectives()
		{
			var usingDirectivesDict = new Dictionary<string, bool>();

			foreach(string u in _necessaryUsings.Concat(UsingDirectives ?? new string[] { }))
				usingDirectivesDict[u] = false;

			return usingDirectivesDict;
		}

		public static Type[] GetAllTableDefinitions(params Type[] typesForAssemblies)
		{
			List<Type> tdTypes = new List<Type>();
			Dictionary<Type, Type> dict = new Dictionary<Type, Type>();

			foreach(Type type in typesForAssemblies) {
				var assembly = Assembly.GetAssembly(type);

				foreach(Type tdType in
					typeof(ITableDefinition)
					.GetTypesImplementingThisInterface(assembly)
					.Where(t => !t.IsInterface)) {
					dict[tdType] = tdType;
				}
			}

			return dict.Values.ToArray();
		}

		public static string AutoGeneratedLine()
			=> $"// ======= auto generated: {_toXmlTime(DateTime.UtcNow)} =======";

		static string _toXmlTime(DateTime dt)
			=> dt.ToString("yyyy-MM-ddTHH-mm-ssZ");

	}
}
